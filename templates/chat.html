{% extends 'base.html' %}
{% load static %}
{% block title %}聊天室{% endblock %}

{% block content %}
<body>
  <div class="chat-container">
    <h1>聊天室</h1>
    {% if conversation.user1.id == request.user.id %}
      <p>聊天對象：{{ conversation.user2.username }}</p>
    {% else %}
      <p>聊天對象：{{ conversation.user1.username }}</p>
    {% endif %}


    <div id="chat-box" class="chat-box">
      <!-- 現有訊息可由伺服器渲染，也可以僅靠 WebSocket 即時加入 -->
      {% for message_item in messages_list %}  {# <<< 從 'messages' 改為 'messages_list' #}
        {% if message_item.sender == request.user %}  {# <<< User 對象與 User 對象比較 #}
          <div class="message right">
            <strong>{{ message_item.sender.username }}:</strong><br> {# <<< 顯式使用 username #}
            {{ message_item.content }}
          </div>
        {% else %}
          <div class="message left">
            <strong>{{ message_item.sender.username }}:</strong><br> {# <<< 顯式使用 username #}
            {{ message_item.content }}
          </div>
        {% endif %}
      {% empty %}
        <p>尚無訊息</p>
      {% endfor %}
    </div>

    <!-- 輸入訊息表單 -->
    <form id="chat-form">
      {% csrf_token %}
      <textarea id="message-input" rows="3" cols="50" placeholder="請輸入訊息..."></textarea><br>
      <button type="submit">送出</button>
    </form>
  </div>
</body>
<script>
    window.onload = function() {
    const chatBox = document.getElementById('chat-box');
    chatBox.scrollTop = chatBox.scrollHeight;
  };
  // 根據使用者角色決定房間名稱前綴
  const roomPrefix = "{% if conversation.user1.id == request.user.id %}chat_buyer{% else %}chat_seller{% endif %}";
  const roomID = "{{ conversation.id }}";
  const roomName = roomPrefix + '_' + roomID;

  // 利用 console.log 印出 roomID，方便在瀏覽器中檢查它是否正確
  console.log("Generated roomID:", roomID);

  const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
  const socketUrl = protocol + window.location.host + '/ws/chat/' + roomID + '/';


  // 用 console.log 檢查生成的 URL
  console.log('Socket URL:', socketUrl);

  const chatSocket = new WebSocket(socketUrl);

  // 當連線成功建立時
  chatSocket.onopen = function(e) {
    console.log('WebSocket 連線已建立');
  };

  // 當收到訊息時，更新聊天框內容
  chatSocket.onmessage = function(e) {
    console.log("JS onmessage: 收到 WebSocket 數據:", e.data);
    const data = JSON.parse(e.data);
    const messageContent = data['message'];
    const senderUsername = data['sender'];
    const chatBox = document.getElementById('chat-box');

    // 建立新的訊息區塊
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');

    // 判斷發送者決定顯示在左或右
    if (senderUsername === '{{ request.user.username }}') {
      messageDiv.classList.add('right');
    } else {
      messageDiv.classList.add('left');
    }

    messageDiv.innerHTML = '<strong>' + senderUsername + ':</strong><br>' + messageContent;
    chatBox.appendChild(messageDiv);
    
    // 自動捲到最底部
    chatBox.scrollTop = chatBox.scrollHeight;
  };
  
  // 建立連線錯誤或連線關閉時的處理
  chatSocket.onerror = function(e) {
    console.error('WebSocket 連線錯誤:', e);
  };
  chatSocket.onclose = function(e) {
    console.error('聊天室連線意外中斷');
  };

  // 發送訊息
  document.getElementById('chat-form').onsubmit = function(e) {
    e.preventDefault();
    const messageInputDom = document.getElementById('message-input');
    const messageToSend = messageInputDom.value;
    if (messageToSend.trim() === '') {
      return;
    }
    // 確認 WebSocket 連線狀態是否處於開啟狀態
    if (chatSocket.readyState === WebSocket.OPEN) {
      chatSocket.send(JSON.stringify({
        'message': messageToSend,
      }));
      messageInputDom.value = '';
    } else {
      console.error('WebSocket 連線尚未開啟或已關閉');
    }
  };
</script>
{% endblock %}